/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace Arena {
  export type MatchStruct = {
    id: BytesLike;
    creator: AddressLike;
    opponent: AddressLike;
    mode: BigNumberish;
    stakeAmount: BigNumberish;
    challengeHash: BytesLike;
    status: BigNumberish;
    winner: AddressLike;
    createdAt: BigNumberish;
    resolvedAt: BigNumberish;
    timeLimit: BigNumberish;
  };

  export type MatchStructOutput = [
    id: string,
    creator: string,
    opponent: string,
    mode: bigint,
    stakeAmount: bigint,
    challengeHash: string,
    status: bigint,
    winner: string,
    createdAt: bigint,
    resolvedAt: bigint,
    timeLimit: bigint
  ] & {
    id: string;
    creator: string;
    opponent: string;
    mode: bigint;
    stakeAmount: bigint;
    challengeHash: string;
    status: bigint;
    winner: string;
    createdAt: bigint;
    resolvedAt: bigint;
    timeLimit: bigint;
  };
}

export interface ArenaInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "ENTRY_FEE"
      | "MATCH_TIMEOUT"
      | "MAX_PROTOCOL_FEE_BPS"
      | "cancelMatch"
      | "createMatch"
      | "gameToken"
      | "getEntryFee"
      | "getMatch"
      | "getMempool"
      | "joinMatch"
      | "matchCounter"
      | "matches"
      | "mempool"
      | "oracle"
      | "owner"
      | "pause"
      | "paused"
      | "playerStakes"
      | "protocolFeeBps"
      | "refundExpiredMatch"
      | "renounceOwnership"
      | "resolveMatch"
      | "totalTreasuryFees"
      | "transferOwnership"
      | "unpause"
      | "updateMempool"
      | "updateOracle"
      | "updateProtocolFee"
      | "withdrawTreasuryFees"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "EntryFeePaid"
      | "MatchCancelled"
      | "MatchCreated"
      | "MatchJoined"
      | "MatchRefunded"
      | "MatchResolved"
      | "MatchStarted"
      | "MempoolUpdated"
      | "OracleUpdated"
      | "OwnershipTransferred"
      | "Paused"
      | "ProtocolFeeUpdated"
      | "TreasuryWithdrawal"
      | "Unpaused"
  ): EventFragment;

  encodeFunctionData(functionFragment: "ENTRY_FEE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MATCH_TIMEOUT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_PROTOCOL_FEE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelMatch",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createMatch",
    values: [BigNumberish, BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "gameToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getEntryFee",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getMatch", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getMempool",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "joinMatch",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "matchCounter",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "matches", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "mempool", values?: undefined): string;
  encodeFunctionData(functionFragment: "oracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "playerStakes",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "refundExpiredMatch",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resolveMatch",
    values: [BytesLike, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalTreasuryFees",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateMempool",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateOracle",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateProtocolFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawTreasuryFees",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "ENTRY_FEE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MATCH_TIMEOUT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_PROTOCOL_FEE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gameToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getEntryFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getMatch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMempool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "joinMatch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "matchCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "matches", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mempool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "playerStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refundExpiredMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveMatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalTreasuryFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateMempool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawTreasuryFees",
    data: BytesLike
  ): Result;
}

export namespace EntryFeePaidEvent {
  export type InputTuple = [
    player: AddressLike,
    matchId: BytesLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [player: string, matchId: string, amount: bigint];
  export interface OutputObject {
    player: string;
    matchId: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchCancelledEvent {
  export type InputTuple = [matchId: BytesLike, reason: string];
  export type OutputTuple = [matchId: string, reason: string];
  export interface OutputObject {
    matchId: string;
    reason: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchCreatedEvent {
  export type InputTuple = [
    matchId: BytesLike,
    creator: AddressLike,
    mode: BigNumberish,
    stakeAmount: BigNumberish,
    challengeHash: BytesLike
  ];
  export type OutputTuple = [
    matchId: string,
    creator: string,
    mode: bigint,
    stakeAmount: bigint,
    challengeHash: string
  ];
  export interface OutputObject {
    matchId: string;
    creator: string;
    mode: bigint;
    stakeAmount: bigint;
    challengeHash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchJoinedEvent {
  export type InputTuple = [matchId: BytesLike, opponent: AddressLike];
  export type OutputTuple = [matchId: string, opponent: string];
  export interface OutputObject {
    matchId: string;
    opponent: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchRefundedEvent {
  export type InputTuple = [
    matchId: BytesLike,
    player: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [matchId: string, player: string, amount: bigint];
  export interface OutputObject {
    matchId: string;
    player: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchResolvedEvent {
  export type InputTuple = [
    matchId: BytesLike,
    winner: AddressLike,
    loser: AddressLike,
    payout: BigNumberish
  ];
  export type OutputTuple = [
    matchId: string,
    winner: string,
    loser: string,
    payout: bigint
  ];
  export interface OutputObject {
    matchId: string;
    winner: string;
    loser: string;
    payout: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MatchStartedEvent {
  export type InputTuple = [matchId: BytesLike];
  export type OutputTuple = [matchId: string];
  export interface OutputObject {
    matchId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MempoolUpdatedEvent {
  export type InputTuple = [oldMempool: AddressLike, newMempool: AddressLike];
  export type OutputTuple = [oldMempool: string, newMempool: string];
  export interface OutputObject {
    oldMempool: string;
    newMempool: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OracleUpdatedEvent {
  export type InputTuple = [oldOracle: AddressLike, newOracle: AddressLike];
  export type OutputTuple = [oldOracle: string, newOracle: string];
  export interface OutputObject {
    oldOracle: string;
    newOracle: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProtocolFeeUpdatedEvent {
  export type InputTuple = [oldFee: BigNumberish, newFee: BigNumberish];
  export type OutputTuple = [oldFee: bigint, newFee: bigint];
  export interface OutputObject {
    oldFee: bigint;
    newFee: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TreasuryWithdrawalEvent {
  export type InputTuple = [to: AddressLike, amount: BigNumberish];
  export type OutputTuple = [to: string, amount: bigint];
  export interface OutputObject {
    to: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Arena extends BaseContract {
  connect(runner?: ContractRunner | null): Arena;
  waitForDeployment(): Promise<this>;

  interface: ArenaInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  ENTRY_FEE: TypedContractMethod<[], [bigint], "view">;

  MATCH_TIMEOUT: TypedContractMethod<[], [bigint], "view">;

  MAX_PROTOCOL_FEE_BPS: TypedContractMethod<[], [bigint], "view">;

  cancelMatch: TypedContractMethod<[matchId: BytesLike], [void], "nonpayable">;

  createMatch: TypedContractMethod<
    [
      mode: BigNumberish,
      stakeAmount: BigNumberish,
      challengeHash: BytesLike,
      timeLimit: BigNumberish
    ],
    [string],
    "nonpayable"
  >;

  gameToken: TypedContractMethod<[], [string], "view">;

  getEntryFee: TypedContractMethod<[], [bigint], "view">;

  getMatch: TypedContractMethod<
    [matchId: BytesLike],
    [Arena.MatchStructOutput],
    "view"
  >;

  getMempool: TypedContractMethod<[], [string], "view">;

  joinMatch: TypedContractMethod<[matchId: BytesLike], [void], "payable">;

  matchCounter: TypedContractMethod<[], [bigint], "view">;

  matches: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        bigint,
        bigint
      ] & {
        id: string;
        creator: string;
        opponent: string;
        mode: bigint;
        stakeAmount: bigint;
        challengeHash: string;
        status: bigint;
        winner: string;
        createdAt: bigint;
        resolvedAt: bigint;
        timeLimit: bigint;
      }
    ],
    "view"
  >;

  mempool: TypedContractMethod<[], [string], "view">;

  oracle: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  pause: TypedContractMethod<[], [void], "nonpayable">;

  paused: TypedContractMethod<[], [boolean], "view">;

  playerStakes: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  protocolFeeBps: TypedContractMethod<[], [bigint], "view">;

  refundExpiredMatch: TypedContractMethod<
    [matchId: BytesLike],
    [void],
    "nonpayable"
  >;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  resolveMatch: TypedContractMethod<
    [matchId: BytesLike, winner: AddressLike, signature: BytesLike],
    [void],
    "nonpayable"
  >;

  totalTreasuryFees: TypedContractMethod<[], [bigint], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  unpause: TypedContractMethod<[], [void], "nonpayable">;

  updateMempool: TypedContractMethod<
    [newMempool: AddressLike],
    [void],
    "nonpayable"
  >;

  updateOracle: TypedContractMethod<
    [newOracle: AddressLike],
    [void],
    "nonpayable"
  >;

  updateProtocolFee: TypedContractMethod<
    [newFeeBps: BigNumberish],
    [void],
    "nonpayable"
  >;

  withdrawTreasuryFees: TypedContractMethod<
    [to: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "ENTRY_FEE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MATCH_TIMEOUT"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_PROTOCOL_FEE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "cancelMatch"
  ): TypedContractMethod<[matchId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "createMatch"
  ): TypedContractMethod<
    [
      mode: BigNumberish,
      stakeAmount: BigNumberish,
      challengeHash: BytesLike,
      timeLimit: BigNumberish
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "gameToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getEntryFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getMatch"
  ): TypedContractMethod<
    [matchId: BytesLike],
    [Arena.MatchStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMempool"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "joinMatch"
  ): TypedContractMethod<[matchId: BytesLike], [void], "payable">;
  getFunction(
    nameOrSignature: "matchCounter"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "matches"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        bigint,
        bigint
      ] & {
        id: string;
        creator: string;
        opponent: string;
        mode: bigint;
        stakeAmount: bigint;
        challengeHash: string;
        status: bigint;
        winner: string;
        createdAt: bigint;
        resolvedAt: bigint;
        timeLimit: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "mempool"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "oracle"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "paused"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "playerStakes"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "protocolFeeBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "refundExpiredMatch"
  ): TypedContractMethod<[matchId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "resolveMatch"
  ): TypedContractMethod<
    [matchId: BytesLike, winner: AddressLike, signature: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "totalTreasuryFees"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "unpause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateMempool"
  ): TypedContractMethod<[newMempool: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateOracle"
  ): TypedContractMethod<[newOracle: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateProtocolFee"
  ): TypedContractMethod<[newFeeBps: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawTreasuryFees"
  ): TypedContractMethod<[to: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "EntryFeePaid"
  ): TypedContractEvent<
    EntryFeePaidEvent.InputTuple,
    EntryFeePaidEvent.OutputTuple,
    EntryFeePaidEvent.OutputObject
  >;
  getEvent(
    key: "MatchCancelled"
  ): TypedContractEvent<
    MatchCancelledEvent.InputTuple,
    MatchCancelledEvent.OutputTuple,
    MatchCancelledEvent.OutputObject
  >;
  getEvent(
    key: "MatchCreated"
  ): TypedContractEvent<
    MatchCreatedEvent.InputTuple,
    MatchCreatedEvent.OutputTuple,
    MatchCreatedEvent.OutputObject
  >;
  getEvent(
    key: "MatchJoined"
  ): TypedContractEvent<
    MatchJoinedEvent.InputTuple,
    MatchJoinedEvent.OutputTuple,
    MatchJoinedEvent.OutputObject
  >;
  getEvent(
    key: "MatchRefunded"
  ): TypedContractEvent<
    MatchRefundedEvent.InputTuple,
    MatchRefundedEvent.OutputTuple,
    MatchRefundedEvent.OutputObject
  >;
  getEvent(
    key: "MatchResolved"
  ): TypedContractEvent<
    MatchResolvedEvent.InputTuple,
    MatchResolvedEvent.OutputTuple,
    MatchResolvedEvent.OutputObject
  >;
  getEvent(
    key: "MatchStarted"
  ): TypedContractEvent<
    MatchStartedEvent.InputTuple,
    MatchStartedEvent.OutputTuple,
    MatchStartedEvent.OutputObject
  >;
  getEvent(
    key: "MempoolUpdated"
  ): TypedContractEvent<
    MempoolUpdatedEvent.InputTuple,
    MempoolUpdatedEvent.OutputTuple,
    MempoolUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "OracleUpdated"
  ): TypedContractEvent<
    OracleUpdatedEvent.InputTuple,
    OracleUpdatedEvent.OutputTuple,
    OracleUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "Paused"
  ): TypedContractEvent<
    PausedEvent.InputTuple,
    PausedEvent.OutputTuple,
    PausedEvent.OutputObject
  >;
  getEvent(
    key: "ProtocolFeeUpdated"
  ): TypedContractEvent<
    ProtocolFeeUpdatedEvent.InputTuple,
    ProtocolFeeUpdatedEvent.OutputTuple,
    ProtocolFeeUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "TreasuryWithdrawal"
  ): TypedContractEvent<
    TreasuryWithdrawalEvent.InputTuple,
    TreasuryWithdrawalEvent.OutputTuple,
    TreasuryWithdrawalEvent.OutputObject
  >;
  getEvent(
    key: "Unpaused"
  ): TypedContractEvent<
    UnpausedEvent.InputTuple,
    UnpausedEvent.OutputTuple,
    UnpausedEvent.OutputObject
  >;

  filters: {
    "EntryFeePaid(address,bytes32,uint256)": TypedContractEvent<
      EntryFeePaidEvent.InputTuple,
      EntryFeePaidEvent.OutputTuple,
      EntryFeePaidEvent.OutputObject
    >;
    EntryFeePaid: TypedContractEvent<
      EntryFeePaidEvent.InputTuple,
      EntryFeePaidEvent.OutputTuple,
      EntryFeePaidEvent.OutputObject
    >;

    "MatchCancelled(bytes32,string)": TypedContractEvent<
      MatchCancelledEvent.InputTuple,
      MatchCancelledEvent.OutputTuple,
      MatchCancelledEvent.OutputObject
    >;
    MatchCancelled: TypedContractEvent<
      MatchCancelledEvent.InputTuple,
      MatchCancelledEvent.OutputTuple,
      MatchCancelledEvent.OutputObject
    >;

    "MatchCreated(bytes32,address,uint8,uint256,bytes32)": TypedContractEvent<
      MatchCreatedEvent.InputTuple,
      MatchCreatedEvent.OutputTuple,
      MatchCreatedEvent.OutputObject
    >;
    MatchCreated: TypedContractEvent<
      MatchCreatedEvent.InputTuple,
      MatchCreatedEvent.OutputTuple,
      MatchCreatedEvent.OutputObject
    >;

    "MatchJoined(bytes32,address)": TypedContractEvent<
      MatchJoinedEvent.InputTuple,
      MatchJoinedEvent.OutputTuple,
      MatchJoinedEvent.OutputObject
    >;
    MatchJoined: TypedContractEvent<
      MatchJoinedEvent.InputTuple,
      MatchJoinedEvent.OutputTuple,
      MatchJoinedEvent.OutputObject
    >;

    "MatchRefunded(bytes32,address,uint256)": TypedContractEvent<
      MatchRefundedEvent.InputTuple,
      MatchRefundedEvent.OutputTuple,
      MatchRefundedEvent.OutputObject
    >;
    MatchRefunded: TypedContractEvent<
      MatchRefundedEvent.InputTuple,
      MatchRefundedEvent.OutputTuple,
      MatchRefundedEvent.OutputObject
    >;

    "MatchResolved(bytes32,address,address,uint256)": TypedContractEvent<
      MatchResolvedEvent.InputTuple,
      MatchResolvedEvent.OutputTuple,
      MatchResolvedEvent.OutputObject
    >;
    MatchResolved: TypedContractEvent<
      MatchResolvedEvent.InputTuple,
      MatchResolvedEvent.OutputTuple,
      MatchResolvedEvent.OutputObject
    >;

    "MatchStarted(bytes32)": TypedContractEvent<
      MatchStartedEvent.InputTuple,
      MatchStartedEvent.OutputTuple,
      MatchStartedEvent.OutputObject
    >;
    MatchStarted: TypedContractEvent<
      MatchStartedEvent.InputTuple,
      MatchStartedEvent.OutputTuple,
      MatchStartedEvent.OutputObject
    >;

    "MempoolUpdated(address,address)": TypedContractEvent<
      MempoolUpdatedEvent.InputTuple,
      MempoolUpdatedEvent.OutputTuple,
      MempoolUpdatedEvent.OutputObject
    >;
    MempoolUpdated: TypedContractEvent<
      MempoolUpdatedEvent.InputTuple,
      MempoolUpdatedEvent.OutputTuple,
      MempoolUpdatedEvent.OutputObject
    >;

    "OracleUpdated(address,address)": TypedContractEvent<
      OracleUpdatedEvent.InputTuple,
      OracleUpdatedEvent.OutputTuple,
      OracleUpdatedEvent.OutputObject
    >;
    OracleUpdated: TypedContractEvent<
      OracleUpdatedEvent.InputTuple,
      OracleUpdatedEvent.OutputTuple,
      OracleUpdatedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "Paused(address)": TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;
    Paused: TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;

    "ProtocolFeeUpdated(uint256,uint256)": TypedContractEvent<
      ProtocolFeeUpdatedEvent.InputTuple,
      ProtocolFeeUpdatedEvent.OutputTuple,
      ProtocolFeeUpdatedEvent.OutputObject
    >;
    ProtocolFeeUpdated: TypedContractEvent<
      ProtocolFeeUpdatedEvent.InputTuple,
      ProtocolFeeUpdatedEvent.OutputTuple,
      ProtocolFeeUpdatedEvent.OutputObject
    >;

    "TreasuryWithdrawal(address,uint256)": TypedContractEvent<
      TreasuryWithdrawalEvent.InputTuple,
      TreasuryWithdrawalEvent.OutputTuple,
      TreasuryWithdrawalEvent.OutputObject
    >;
    TreasuryWithdrawal: TypedContractEvent<
      TreasuryWithdrawalEvent.InputTuple,
      TreasuryWithdrawalEvent.OutputTuple,
      TreasuryWithdrawalEvent.OutputObject
    >;

    "Unpaused(address)": TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
    Unpaused: TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
  };
}
